    /**
     * Allows automatic render target (OpenGL, Vulkan, Metal, DX) passthrough instantiation.
     * This can basically pass a file location off to your rendering engine and autoload it into memory.
     */
    public static void setFontStringCall(FontLoadingCalls.StringCall stringCall) {
        if (stringUpload != null) {
            throw new RuntimeException("Font: Tried to set the string api integration function more than once!");
        }
        stringUpload = stringCall;
    }
    /**
     * Allows automatic render target (OpenGL, Vulkan, Metal, DX) DIRECT instantiation.
     * This allows the render engine to AUTOMATICALLY upload the image as RAW data.
     * byte[] = raw data. int = width. int = height.
     */
    public static void setFontRawCall(FontLoadingCalls.RawCall rawCall) {
        if (rawUpload != null) {
            throw new RuntimeException("Font: Tried to set the raw api integration function more than once!");
        }
        rawUpload = rawCall;
    }

    /**
     * Allows automatic render target (OpenGL, Vulkan, Metal, DX) DIRECT rendering via RazorFont.
     * You can simply call render() on the library, and it will automatically do whatever you
     * tell it to with this delegate function. This will also automatically run flush().
     */
    public static void setRenderCall(RenderCall newRenderCall) {
        if (renderCall != null) {
            throw new RuntimeException("Font: Tried to set the render api call more than once!");
        }
        renderCall = newRenderCall;
    }

            // Are we using the fileLocation as the key, or did they specify a name?
    //        final String key = Objects.equals(name, "") ? fileLocation : name;


        /**
         Allows you to blanket set the color for the entire canvas.
         Be careful though, this overwrites the entire color cache
         after the currently rendered character position in memory!
         */
        public static void switchColor(float r, float g, float b) {
            switchColor(r,g,b,1);
        }
        public static void switchColor(float r, float g, float b, float a) {
            for (int i = colorCount; i < colorCache.length; i += 4) {
                colorCache[i]     = r;
                colorCache[i + 1] = g;
                colorCache[i + 2] = b;
                colorCache[i + 3] = a;
            }
        }

            /**
             Allows you to set the offet of the text shadowing.
             This is RELATIVE via the font size so it will remain consistent
             across any font size!
             Remember: Offset will become reset to default when you call renderToCanvas()
             */
            public static void setShadowOffset(float x, float y) {
                shadowOffsetX = x / 10.0f;
                shadowOffsetY = y / 10.0f;
            }

            /**
             Allows you to blanket set the shadow color for the entire canvas after the current character.
             Remember: When you renderToCanvas() shadow colors will default back to black.
             */
            public static void switchShadowColor(float r, float g, float b) {
                switchShadowColor(r,g,b,1);
            }
            public static void switchShadowColor(float r, float g, float b, float a) {
                shadowColor[0] = r;
                shadowColor[1] = g;
                shadowColor[2] = b;
                shadowColor[3] = a;
            }


    /**
     Allows you to blanket a range of characters in the canvas with a color.
     So if you have: abcdefg
     And run setColorRange(0.5,0.5,0.5, 1, 3, 5)
     Now e and f are gray. Alpha 1.0
     */
    public static void setColorRange(int start, int end, float r, float g, float b) {
        setColorRange(start, end, r,g,b,1);
    }
    public static void setColorRange(int start, int end, float r, float g, float b, float a) {
        for (int i = start * 16; i < end * 16; i += 4) {
            colorCache[i]     = r;
            colorCache[i + 1] = g;
            colorCache[i + 2] = b;
            colorCache[i + 3] = a;
        }
    }


 /**
     Allows you to set individual character colors
     */
    public static void setColorChar(int charIndex, float r, float g, float b) {
        setColorChar(charIndex, r,g,b,1);
    }
    public static void setColorChar(int charIndex, float r, float g, float b, float a) {
        final int startIndex = charIndex * 16;
        for (int i = startIndex; i < startIndex + 16; i += 4) {
            colorCache[i]     = r;
            colorCache[i + 1] = g;
            colorCache[i + 2] = b;
            colorCache[i + 3] = a;
        }
    }

    /**
     Allows you to directly work on vertex position colors in a character.
     Using direct points (verbose)
     */
    public static void setColorPoints(
            int charIndex,

            float topLeftR,
            float topLeftG,
            float topLeftB,
            float topLeftA,

            float bottomLeftR,
            float bottomLeftG,
            float bottomLeftB,
            float bottomLeftA,

            float bottomRightR,
            float bottomRightG,
            float bottomRightB,
            float bottomRightA,

            float topRightR,
            float topRightG,
            float topRightB,
            float topRightA
    ) {
        final int startIndex = charIndex * 16;

        // It's already immensely verbose, let's just add on to this verbosity

        colorCache[startIndex]      = topLeftR;
        colorCache[startIndex + 1]  = topLeftG;
        colorCache[startIndex + 2]  = topLeftB;
        colorCache[startIndex + 3]  = topLeftA;

        colorCache[startIndex + 4]  = bottomLeftR;
        colorCache[startIndex + 5]  = bottomLeftG;
        colorCache[startIndex + 6]  = bottomLeftB;
        colorCache[startIndex + 7]  = bottomLeftA;

        colorCache[startIndex + 8]  = bottomRightR;
        colorCache[startIndex + 9]  = bottomRightG;
        colorCache[startIndex + 10] = bottomRightB;
        colorCache[startIndex + 11] = bottomRightA;

        colorCache[startIndex + 12] = topRightR;
        colorCache[startIndex + 13] = topRightG;
        colorCache[startIndex + 14] = topRightB;
        colorCache[startIndex + 15] = topRightA;
    }

    /**
     Allows you to directly work on vertex position colors in a character.
     Using direct points (tidy).
     float vec is [R,G,B,A]
     */
    public static void setColorPoints(int charIndex, float[] topLeft, float[] bottomLeft, float[] bottomRight, float[] topRight) {
        final int startIndex = charIndex * 16;
        int externalIndex = 0;
        for(float[] vec4 : new float[][]{topLeft, bottomLeft, bottomRight, topRight}) {
            int index = 0;
            for (float value : vec4) {
                colorCache[startIndex + (externalIndex * 4) + index] = value;
                index++;
            }
            externalIndex++;

        }
    }
    // Allows you to get the max amount of characters allowed in canvas
    public static int getMaxChars() {
        return CHARACTER_LIMIT;
    }


    /**
     Allows you to index the current amount of characters on the canvas. This does
     not include spaces and carriage returns. You MUST call renderToCanvas before
     calling this otherwise this will always be 0 when you call it.
     */
    public static int getCurrentCharacterIndex() {
        return chars;
    }




    /**
     Allows you to extract the current font PNG file location automatically
     */
    public static String getCurrentFontTextureFileLocation() {
        if (currentFont == null) {
            throw new RuntimeException("Font: Can't get a font file location! You didn't select one!");
        }
        return currentFont.fileLocation;
    }

    /**
     Turns on shadowing.
     Remember: This creates twice as many characters because
     you have to render a background, then a foreground.
     You can also do some crazy stuff with shadows because the shadow
     colors are stored in the same color cache as regular text.
     Remember: When you renderToCanvas() shadows turn off.
     */
    public static void enableShadows() {
        shadowsEnabled = true;
    }

    // Allows you to render to a canvas using top left as a base position
    // This is now modified to be less UNIXy, calling straight into the Window class
//    public static void updateCanvasSize(/*float width, float height*/) {
        // Dividing by 2.0 because my test environment shader renders to center on pos(0,0) top left
//        Vector2i windowSize =  Window.getWindowSize();

//        canvasWidth  = (float)windowSize.x / 2.0f;
//        canvasHeight = (float)windowSize.y / 2.0f;
//    }

/**
     Automatically flushes out the cache, handing the data structure off to
     the delegate function you defined via setRenderFunc()
     */
    public static void render() {
        if (renderCall == null) {
            throw new RuntimeException("Font: You did not set a render api call!");
        }
        renderCall.draw(flush());
    }

     /// Allows you to get text size to do interesting things. Returns as RazorTextSize struct
        public static Vector2f getTextSize(float fontSize, String text) {
            float accumulatorX = 0.0f;
            float accumulatorY = 0.0f;
            // Cache spacing
            final float spacing = currentFont.spacing * fontSize;
            // Cache space (' ') character
            final float spaceCharacterSize = currentFont.spaceCharacterSize * fontSize;

            // Can't get the size if there's no font!
            if (currentFont == null) {
                throw new RuntimeException("Razor Font: Tried to get text size without selecting a font! " +
                        "You must select a font before getting the size of text with it!");
            }

            for (char character : text.toCharArray()) {

                String currentStringChar = String.valueOf(character);

                // Skip space
                if (character == ' ') {
                    accumulatorX += spaceCharacterSize;
                    continue;
                }
                // Move down 1 space Y
                if (character == '\n') {
                    accumulatorY += fontSize;
                    continue;
                }

                // Skip unknown character
                if (!currentFont.map.containsKey(currentStringChar)) {
                    continue;
                }

                // Font stores character width in index 9 (8 [0 count])
                accumulatorX += (currentFont.map.get(currentStringChar)[8] * fontSize) + spacing;
            }


            // Add a last bit of the height offset
            accumulatorY += fontSize;
            // Remove the last bit of spacing
            accumulatorX -= spacing;

            // Finally, if shadowing is enabled, add in shadowing offset
            if (shadowsEnabled) {
                accumulatorX += (shadowOffsetX * fontSize);
                accumulatorY += (shadowOffsetY * fontSize);
            }

            return new Vector2f(accumulatorX, accumulatorY);
        }

            /**
             * Get the name of the currently used font
             */
            public static String getCurrentFontName() {
                return currentFontName;
            }




            NOTE!!! THIS IS THE COMMENT FOR THE OLD RENDER TO CANVAS FUNCTION! IT SUCKS

            /**
                 Render to the canvas. Remember: You must run flush() to collect this canvas.
                 If rounding is enabled, it will attempt to keep your text aligned with the pixels on screen
                 to avoid wavy/blurry/jagged text. This will automatically render shadows for you as well.
                 */



 /**
      Rotate a character around the center point of its face.
      Note: This defaults to radians by default.
      Note: If you use moveChar() with this, you MUST do moveChar() first!
      */
     public static void rotateChar(int index, float rotation) {
         rotateChar(index,rotation,false);
     }
     public static void rotateChar(int index, float rotation, boolean isDegrees) {

         // Degrees are annoying
         if (isDegrees) {
             final float radToDegrees = 180.0f / (float)Math.PI;
             rotation *= radToDegrees;
         }

         /*
          This is written out even more verbosely than moveChar()
          so you can see why you must do moveChar() first.
          */

         // Move to cursor position in vertexCache
         final int baseIndex = index * 8;

         // Convert to 3d to supplement to 4x4 matrix
         Vector3f topLeft     = new Vector3f(vertexCache[baseIndex    ], vertexCache[baseIndex + 1], 0);
         Vector3f bottomLeft  = new Vector3f(vertexCache[baseIndex + 2], vertexCache[baseIndex + 3], 0);
         Vector3f bottomRight = new Vector3f(vertexCache[baseIndex + 4], vertexCache[baseIndex + 5], 0);
         Vector3f topRight    = new Vector3f(vertexCache[baseIndex + 6], vertexCache[baseIndex + 7], 0);

         Vector3f centerPoint = new Vector3f((topLeft.x + topRight.x) / 2.0f,  (topLeft.y + bottomLeft.y) / 2.0f, 0);

         Vector3f topLeftDiff      = new Vector3f(topLeft)    .sub(centerPoint);
         Vector3f bottomLeftDiff   = new Vector3f(bottomLeft) .sub(centerPoint);
         Vector3f bottomRightDiff = new Vector3f(bottomRight).sub(centerPoint);
         Vector3f topRightDiff    = new Vector3f(topRight)   .sub(centerPoint);

         // These calculations also store the new data in the variables we created above
         // We must center the coordinates into real coordinates

         new Matrix4f().rotate(rotation, 0,0,1).translate(topLeftDiff)     .getTranslation(topLeft);
         new Matrix4f().rotate(rotation, 0,0,1).translate(bottomLeftDiff)  .getTranslation(bottomLeft);
         new Matrix4f().rotate(rotation, 0,0,1).translate(bottomRightDiff) .getTranslation(bottomRight);
         new Matrix4f().rotate(rotation, 0,0,1).translate(topRightDiff)    .getTranslation(topRight);


         topLeft.x += centerPoint.x;
         topLeft.y += centerPoint.y;

         bottomLeft.x += centerPoint.x;
         bottomLeft.y += centerPoint.y;

         bottomRight.x += centerPoint.x;
         bottomRight.y += centerPoint.y;

         topRight.x += centerPoint.x;
         topRight.y += centerPoint.y;

         vertexCache[baseIndex    ] = topLeft.x;
         vertexCache[baseIndex + 1] = topLeft.y;

         vertexCache[baseIndex + 2] = bottomLeft.x;
         vertexCache[baseIndex + 3] = bottomLeft.y;

         vertexCache[baseIndex + 4] = bottomRight.x;
         vertexCache[baseIndex + 5] = bottomRight.y;

         vertexCache[baseIndex + 6] = topRight.x;
         vertexCache[baseIndex + 7] = topRight.y;
     }


// ========================== BEGIN API AGNOSTIC CALLS ============================
    // Attempts to automate the api RAW call
    private static void tryCallingRAWApi(String fileLocation) {
        if (rawUpload == null) {
            return;
        }

        RawTextureObject tempImageObject = new RawTextureObject(fileLocation);

        final int width = tempImageObject.getWidth();
        final int height = tempImageObject.getHeight();

        rawUpload.fontLoadCallRaw(tempImageObject.getBuffer(), width, height);

        // Garbage collected :P
        tempImageObject.destroy();
    }

    // Attempts to automate the api String call
    private static void tryCallingStringApi(String fileLocation) {
        if (stringUpload == null) {
            return;
        }

        stringUpload.fontLoadCallString(fileLocation);
    }

    // ======================= END API AGNOSTIC CALLS ================================



    public static void renderToCanvas(float posX, float posY, final float fontSize, String text) {
            renderToCanvas(posX, posY, fontSize, text,true);
        }
        public static void renderToCanvas(float posX, float posY, final float fontSize, String text, boolean rounding) {

            // Keep square pixels
            if (rounding) {
                posX = Math.round(posX);
                posY = Math.round(posY);
            }

            // Can't render if no font is selected
            if (currentFont == null) {
                throw new RuntimeException("Font: Tried to render without selecting a font! " +
                        "You must select a font before rendering to canvas!");
            }

            // Store how far the arm has moved to the right
            float typeWriterArmX = 0.0f;
            // Store how far the arm has moved down
            float typeWriterArmY = 0.0f;

            // Top left of canvas is root position (X: 0, y: 0)
            final float positionX = posX;
            final float positionY = posY;

                // Cache spacing
            final float spacing = currentFont.spacing * fontSize;

                // Cache space (' ') character
            final float spaceCharacterSize = currentFont.spaceCharacterSize * fontSize;

            for (char character : text.toCharArray()) {

                // Skip space
                if (character == ' ') {
                    typeWriterArmX += spaceCharacterSize;
                    continue;
                }
                // Move down 1 space Y and to space 0 X
                if (character == '\n') {
                    typeWriterArmY += fontSize;
                    typeWriterArmX = 0.0f;
                    continue;
                }

                String stringCharacter = String.valueOf(character);

                // Skip unknown character
                if (!currentFont.map.containsKey(stringCharacter)) {
                    continue;
                }

                // Font stores character width in index 9 (8 [0 count])
                float[] textureData = Arrays.copyOfRange(currentFont.map.get(stringCharacter), 0, 9);

    //            System.out.println(stringCharacter);
    //            if (stringCharacter.equals("h")) {
    //                System.out.println(Arrays.toString(currentFont.map.get(stringCharacter)));
    //            }

                //Now dispatch into the cache
                System.arraycopy(textureData, 0, textureCoordinateCache, textureCoordinateCount, 8);

                // This is the width of the character
                // Keep on the stack
                float characterWidth = textureData[8];

                // Keep this on the stack
                float[] rawVertex = Arrays.copyOf(RAW_VERTEX, RAW_VERTEX.length);


                // ( 0 x 1 y 2 x 3 y ) <- left side ( 4 x 5 y 6 x 7 y ) <- right side is goal
                // Now apply trimming
                for (int i = 4; i < 8; i += 2) {
                    rawVertex[i] = characterWidth;
                }

                // Now scale
                for (int i = 0; i < rawVertex.length; i++) {
                    rawVertex[i] *= fontSize;
                }

                // Shifting
                for (int i = 0; i < 8; i += 2) {
                    // Now shift right
                    rawVertex[i] += typeWriterArmX + positionX;
                    // Now shift down
                    rawVertex[i + 1] += typeWriterArmY + positionY;
                }

                typeWriterArmX += (characterWidth * fontSize) + spacing;

                // vertexData ~= rawVertex;
                // Now dispatch into the cache
                System.arraycopy(rawVertex, 0, vertexCache, vertexCount, 8);


                int[] rawIndices = Arrays.copyOf(RAW_INDICES, RAW_INDICES.length);

                for (int i = 0; i < rawIndices.length; i++) {
                    rawIndices[i] += vertexCount / 2;
                }

                // Now dispatch into the cache
                System.arraycopy(rawIndices, 0, indicesCache, indicesCount, 6);

                // Now hold cursor position (count) in arrays
                vertexCount  += 8;
                textureCoordinateCount += 8;
                indicesCount += 6;
                colorCount += 16;
                // This one is characters literal
                chars++;

                if (vertexCount >= CHARACTER_LIMIT || indicesCount >= CHARACTER_LIMIT) {
                    throw new RuntimeException("Font: Exceeded character limit! Character limit is: " + CHARACTER_LIMIT);
                }
            }

            /*
             * Because there is no Z buffer in 2d, OpenGL seems to NOT overwrite pixel data of existing
             * framebuffer pixels. Since this is my testbed, I must assume that this is how
             * Vulkan, Metal, DX, and so-on do this. This is GUARANTEED to not affect software renderers.
             * So we have to do the shadowing AFTER the foreground.
             * We need to poll, THEN disable the shadow variable because without that it would be
             * an infinite recursion, aka a stack overflow.
             */
            final boolean shadowsWereEnabled = shadowsEnabled;
            shadowsEnabled = false;
    //        if (shadowsWereEnabled) {
    //            final int textLength = getTextLength(text);
    //            final int currentIndex = getCurrentCharacterIndex();
    //            if (shadowColoringEnabled) {
    //                setColorRange(
    //                        currentIndex,
    //                        currentIndex + textLength,
    //                        shadowColor[0],
    //                        shadowColor[1],
    //                        shadowColor[2],
    //                        shadowColor[3]
    //                );
    //            }
    //            renderToCanvas(posX + (shadowOffsetX * fontSize), posY + (shadowOffsetY * fontSize), fontSize, text, false);
    //
    //            shadowOffsetX = 0.05f;
    //            shadowOffsetY = 0.05f;
    //        }

            // Turn this back on because it can become a confusing nightmare
            shadowColoringEnabled = true;
            // Switch back to black because this also can become a confusing nightmare
    //        switchShadowColor(0,0,0);
        }


            public static int getTextLengthWithShadows(String input) {
                return getTextLength(input) * 2;
            }
            public static void disableShadowColoring() {
                shadowColoringEnabled = false;
            }

            public static void moveChar(int index, float posX, float posY) {
                // This gets a bit confusing, so I'm going to write it out verbosely to be able to read/maintain it

                // Move to cursor position in vertexCache
                final int baseIndex = index * 8;

                // Top left
                vertexCache[baseIndex    ] += posX; // X
                vertexCache[baseIndex + 1] -= posY; // Y

                // Bottom left
                vertexCache[baseIndex + 2] += posX; // X
                vertexCache[baseIndex + 3] -= posY; // Y

                // Bottom right
                vertexCache[baseIndex + 4] += posX; // X
                vertexCache[baseIndex + 5] -= posY; // Y

                // Top right
                vertexCache[baseIndex + 6] += posX; // X
                vertexCache[baseIndex + 7] -= posY; // Y
            }